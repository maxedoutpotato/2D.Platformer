<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ninja Runner</title>
    <style>
        /* Basic styling to center the game and make it look clean */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #282c34;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
        }
        canvas {
            background-color: #f0f0f0;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            /* This makes the canvas responsive */
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Game Constants ---
        const GRAVITY = 2300;
        const JUMP_STRENGTH = -900;
        const PLAYER_SPRITE_WIDTH = 100; // Width of a single frame
        const PLAYER_SPRITE_HEIGHT = 100; // Height of a single frame
        const PLAYER_DRAW_WIDTH = 100;
        const PLAYER_DRAW_HEIGHT = 100;
        const DEBUG_MODE = false; // Set to true to see hitboxes
        
        // --- Physics vs Visuals ---
        const GROUND_HEIGHT_PHYSICS = 68; // This controls the hitbox of the ground.
        const VISUAL_GROUND_Y_OFFSET = -182; // Visual position offset. Negative values move it up.
        const VISUAL_GROUND_HEIGHT = 250;   // Visual thickness of the ground image.

        // *** EDIT HERE to control background visuals ***
        const BG1_Y_POS = -540;
        const BG1_SCALE = 1.75;
        const BG2_Y_POS = -400;
        const BG2_SCALE = 1.3;

        // *** EDIT HERE for mountain visuals ***
        const MOUNTAIN_Y_POS = 40; // Y position of the mountains
        const MOUNTAIN_AVG_SCALE = 0.8; // The average scale of the mountains
        const MOUNTAIN_SCALE_VARIANCE = 0.2;

        // *** EDIT HERE for grass foreground visuals ***
        const GRASS_Y_POS = 235;
        const GRASS_SPEED_MODIFIER = 1.5; // Speed relative to ground (1.0 is same speed)
        const GRASS_SCALE = 2; // Scale of the grass layer

        // *** EDIT HERE for run cloud position ***
        const RUN_CLOUD_OFFSET_X = -70;
        const RUN_CLOUD_OFFSET_Y = 1;

        // This defines the Y-coordinate for the player's feet, using only the physics value.
        const PLAYER_GROUND_LEVEL = canvas.height - GROUND_HEIGHT_PHYSICS - PLAYER_DRAW_HEIGHT;

        // *** EDIT THESE VALUES to change the shuriken's flying heights ***
        const SHURIKEN_FLYING_HEIGHTS = [
            PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - 80,
            PLAYER_GROUND_LEVEL - 25,
            PLAYER_GROUND_LEVEL - 120
        ];

        // --- Game State ---
        let gameStarted = false;
        let gameOver = false;
        let gameWon = false;
        let canRestart = false; // New state to control when restart is allowed
        let isRestarting = false;
        let restartFadeAmount = 0;
        let fadeDirection = 1;
        let groundX = 0;
        let bg1X = 0;
        let bg2X = 0;
        let grassX = 0;
        let gameFrame = 0;
        let gameSpeed = 300; // Pixels per second
        const speedIncreaseRate = 0.3; // Pixels per second, per second
        let obstaclesArray = []; // Array to hold all obstacles
        let sceneryArray = []; // Array for background mountains
        let effectsArray = []; // Array for visual effects like teleport and clouds
        let score = 0;
        let floatingScores = [];
        let scoreMilestone = 1; // Tracks the next 3000-point goal
        let teleportCharges = 0;
        let inversionAmount = 0; // 0 = normal, 1 = fully inverted
        let inversionTarget = 0;
        let lastTime = 0;
        
        // --- Bonus Spawn Tracking ---
        let bonusSpawns = {
            teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
            bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '19000': 0, '21000': 0 }
        };
        const bonusLimits = {
            teleportGold: { '3000': 2, '9000': 1, '15000': 1 },
            bonusPoints: { '3000': 4, '6000': 3, '9000': 2, '12000': 2, '15000': 3, '19000': 2, '21000': 2 }
        };

        // --- Player State ---
        let player = {
            x: 50,
            y: PLAYER_GROUND_LEVEL,
            width: PLAYER_DRAW_WIDTH,
            height: PLAYER_DRAW_HEIGHT,
            velocityY: 0,
            isJumping: false,
            isCrouching: false,
            isTeleporting: false,
            frame: 0,
            frameTimer: 0,
            state: 'run',
            hitbox: { offsetX: 20, offsetY: 18, width: 75, height: 65 },
            crouchHitbox: { offsetX: 10, offsetY: 40, width: 83, height: 45 }
        };

        // --- Animation Data ---
        const animationStates = {
            run: { frames: 10, columns: 4, frameDuration: 0.08 },
            jump: { frames: 23, columns: 5, frameDuration: 0.03},
            crouch: { frames: 10, columns: 4, frameDuration: 0.08 },
            fall: { frames: 26, columns: 6, frameDuration: 0.04 },
            teleport: { frames: 10, columns: 4, frameDuration: 0.035 },
            teleportGold: { frames: 20, columns: 5, frameDuration: 0.05 },
            shuriken: { frames: 6, columns: 3, frameDuration: 0.05 },
            runCloud: { frames: 24, columns: 5, frameDuration: 0.08}
        };

        // --- Asset Loading ---
        const images = {};
        const sounds = {};

        const imageSources = {
            ground: 'Assets/Background/Ground.png',
            background1: 'Assets/Background/Background.1.png',
            background2: 'Assets/Background/Background.2.png',
            mountain: 'Assets/Background/background.mountain.png',
            grass: 'Assets/Background/Grass.png',
            run: 'Assets/Ninja.Main/Run.png',
            jump: 'Assets/Ninja.Main/Jump.png',
            crouch: 'Assets/Ninja.Main/Run.Crouch.png',
            fall: 'Assets/Ninja.Main/Fall.png',
            runCloud: 'Assets/Ninja.Main/Run.Cloud.png',
            teleport: 'Assets/Ninja.Main/Teleport.png',
            teleportLogo: 'Assets/Ninja.Main/Teleport.Logo.png',
            teleportGold: 'Assets/Ninja.Main/Teleport.Gold.png',
            shuriken: 'Assets/Obstacles/Shuriken.png',
            lantern: 'Assets/Obstacles/Lantern.png',
            rock: 'Assets/Obstacles/Rock.png',
            apple: 'Assets/Obstacles/Apple.png',
            carrot: 'Assets/Obstacles/Carrot.png'
        };

        const soundSources = {
            start: 'Audio/Gong.Start.mp3',
            end: 'Audio/Gong.End.mp3',
            jump: 'Audio/Jump.mp3',
            roll: 'Audio/Roll.mp3',
            woosh: 'Audio/Woosh.mp3',
            kabuki: 'Audio/Kabuki.mp3',
            track: 'Audio/Track.mp3',
            fail: 'Audio/Fail.mp3',
            bell: 'Audio/Bell.mp3',
            teleport: 'Audio/Teleport.mp3',
            crouch: 'Audio/Crouch.mp3',
            eat: 'Audio/Eat.mp3',
            secret: 'Audio/Secret.mp3'
        };

        let assetsLoaded = 0;
        let totalAssets = Object.keys(imageSources).length + Object.keys(soundSources).length;

        function preloadAssets() {
            for (const key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = assetLoaded;
                images[key].onerror = () => console.error(`Failed to load image: ${imageSources[key]}`);
            }
            for (const key in soundSources) {
                sounds[key] = new Audio();
                sounds[key].src = soundSources[key];
                if (key === 'track') sounds[key].loop = true;
                sounds[key].oncanplaythrough = assetLoaded;
                sounds[key].onerror = () => console.error(`Failed to load sound: ${soundSources[key]}`);
            }
        }
        
        function assetLoaded() {
            assetsLoaded++;
        }

        // --- Input Handling ---
        document.addEventListener('keydown', function(event) {
            if (isRestarting) return; // Disable all input during restart transition

            if (event.code === 'Space') {
                if ((gameOver || gameWon) && canRestart) {
                    isRestarting = true;
                    canRestart = false; // Prevent multiple restarts
                    return;
                }
                if (!gameStarted) {
                    gameStarted = true;
                    sounds.start.play();
                    sounds.roll.play();
                    sounds.track.play();
                    effectsArray.push(new RunCloud());
                    lastTime = performance.now();
                    gameLoop(lastTime);
                } else if (!player.isJumping && !gameOver) { // Prevent jumping if game is over
                    player.isJumping = true;
                    player.velocityY = JUMP_STRENGTH;
                    player.state = 'jump';
                    player.frame = 0;
                    sounds.jump.currentTime = 0;
                    sounds.jump.play();
                    effectsArray.forEach(effect => { if(effect.startFading) effect.startFading() });
                }
            }
            
            if (gameOver) return; // Block other keys if game is over

            if (event.code === 'KeyS' && gameStarted && !player.isJumping && !player.isCrouching) {
                player.isCrouching = true;
                player.state = 'crouch';
                sounds.crouch.currentTime = 0;
                sounds.crouch.play();
            }
        });

        document.addEventListener('keyup', function(event) {
            if (gameOver || isRestarting) return;
            if (event.code === 'KeyS') {
                player.isCrouching = false;
                player.state = 'run';
            }
        });

        // --- Effect Classes ---
        class VisualEffect {
            constructor() {
                this.markedForDeletion = false;
            }
        }
        
        class TeleportEffect extends VisualEffect {
            constructor(x, y, followsPlayer) {
                super();
                this.image = images.teleport;
                this.spriteWidth = 100;
                this.spriteHeight = 100;
                this.width = 150;
                this.height = 150;
                this.x = x - (this.width - player.width) / 2;
                this.y = y - (this.height - player.height) / 2;
                this.frame = 0;
                this.frameTimer = 0;
                this.followsPlayer = followsPlayer;
            }
            update(deltaTime) {
                if (this.followsPlayer) {
                    this.x = player.x - (this.width - player.width) / 2;
                    this.y = player.y - (this.height - player.height) / 2;
                }
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleport;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame++;
                    this.frameTimer = 0;
                }
                if (this.frame >= stateData.frames) {
                    this.markedForDeletion = true;
                    player.isTeleporting = false;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleport;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }

        class RunCloud extends VisualEffect {
            constructor() {
                super();
                this.image = images.runCloud;
                this.spriteWidth = 100;
                this.spriteHeight = 100;
                this.width = 100;
                this.height = 100;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
                this.y = player.y + RUN_CLOUD_OFFSET_Y;
                this.frame = 0;
                this.frameTimer = 0;
                this.opacity = 0;
                this.isFading = false;
            }
            startFading() {
                this.isFading = true;
            }
            activate() {
                this.isFading = false;
                this.x = player.x + RUN_CLOUD_OFFSET_X;
            }
            update(deltaTime) {
                if (this.isFading) {
                    if (this.opacity > 0) {
                        this.opacity -= 2 * deltaTime;
                        this.x -= gameSpeed * 0.2 * deltaTime;
                    }
                } else {
                    if (this.opacity < 1) this.opacity += 2 * deltaTime;
                    this.x = player.x + RUN_CLOUD_OFFSET_X;
                    this.y = player.y + RUN_CLOUD_OFFSET_Y;
                    
                    this.frameTimer += deltaTime;
                    const stateData = animationStates.runCloud;
                    const dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
                    if (this.frameTimer >= dynamicFrameDuration) {
                        this.frame = (this.frame + 1) % stateData.frames;
                        this.frameTimer = 0;
                    }
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0 && this.opacity > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    const stateData = animationStates.runCloud;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    ctx.restore();
                }
            }
        }

        class FloatingScore {
            constructor(value, x, y, color = {r:0, g:100, b:0}) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.color = color;
                this.opacity = 1;
                this.timer = 0;
            }
            update(deltaTime) {
                this.y -= 30 * deltaTime;
                this.timer += deltaTime;
                if (this.timer > 1.3) this.opacity -= 1.2 * deltaTime;
            }
            draw() {
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.font = '24px "Segoe UI"';
                ctx.fillText(`+${this.value}`, this.x, this.y);
            }
        }
        
        // --- Scenery Classes ---
        class SceneryObject {
            constructor() {
                this.x = canvas.width + Math.random() * 50;
            }
            update(deltaTime) {
                this.x -= gameSpeed * this.speedModifier * deltaTime;
            }
        }

        class Mountain extends SceneryObject {
            constructor() {
                super();
                this.image = images.mountain;
                this.scale = (Math.random() * MOUNTAIN_SCALE_VARIANCE * 1.3) + (MOUNTAIN_AVG_SCALE - MOUNTAIN_SCALE_VARIANCE);
                this.width = this.image.width * this.scale;
                this.height = this.image.height * this.scale;
                this.y = MOUNTAIN_Y_POS;
                this.speedModifier = 0.06;
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        // --- Obstacle Classes ---
        class Obstacle {
             constructor() {
                this.x = canvas.width;
                this.frame = 0;
                this.frameTimer = 0;
                this.passed = false;
             }
             update(deltaTime) {
                this.x -= gameSpeed * this.speedModifier * deltaTime;
             }
        }

        class Shuriken extends Obstacle {
            constructor() {
                super();
                this.image = images.shuriken;
                this.spriteWidth = 50;
                this.spriteHeight = 50;
                this.width = 70;
                this.height = 70;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1.1;
                this.hitbox = { offsetX: 10, offsetY: 10, width: 50, height: 50 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.shuriken;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.shuriken;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                    }
                }
            }
        }

        class Lantern extends Obstacle {
            constructor() {
                super();
                this.image = images.lantern;
                this.width = 90;
                this.height = 90;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height - 1;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 18, offsetY: 10, width: 55, height: 65 };
            }
             draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                    }
                }
             }
        }

        class Rock extends Obstacle {
            constructor() {
                super();
                this.image = images.rock;
                this.width = 140;
                this.height = 130;
                this.y = PLAYER_GROUND_LEVEL + PLAYER_DRAW_HEIGHT - this.height + 20;
                this.speedModifier = 1.0;
                this.hitbox = { offsetX: 35, offsetY: 45 , width: 85, height: 60 };
            }
            draw() {
                 if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    if (DEBUG_MODE) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x + this.hitbox.offsetX, this.y + this.hitbox.offsetY, this.hitbox.width, this.hitbox.height);
                    }
                }
            }
        }

        class TeleportGold extends Obstacle {
            constructor() {
                super();
                this.image = images.teleportGold;
                this.spriteWidth = 80;
                this.spriteHeight = 80;
                this.width = 60;
                this.height = 60;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1;
                this.hitbox = { offsetX: 0, offsetY: 0, width: 60, height: 60 };
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.frameTimer += deltaTime;
                const stateData = animationStates.teleportGold;
                if (this.frameTimer >= stateData.frameDuration) {
                    this.frame = (this.frame + 1) % stateData.frames;
                    this.frameTimer = 0;
                }
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    const stateData = animationStates.teleportGold;
                    const columns = stateData.columns;
                    const frameX = this.frame % columns;
                    const frameY = Math.floor(this.frame / columns);
                    const sourceX = frameX * this.spriteWidth;
                    const sourceY = frameY * this.spriteHeight;
                    ctx.drawImage(this.image, sourceX, sourceY, this.spriteWidth, this.spriteHeight, this.x, this.y, this.width, this.height);
                }
            }
        }

        class BonusPoints extends Obstacle {
            constructor() {
                super();
                this.image = Math.random() < 0.5 ? images.apple : images.carrot;
                this.width = 80;
                this.height = 80;
                this.y = SHURIKEN_FLYING_HEIGHTS[Math.floor(Math.random() * SHURIKEN_FLYING_HEIGHTS.length)];
                this.speedModifier = 1;
                this.hitbox = { offsetX: 0, offsetY: 0, width: 80, height: 80 };
            }
            draw() {
                if (this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        function handleScenery(deltaTime) {
            sceneryArray.forEach(item => item.update(deltaTime));
            sceneryArray = sceneryArray.filter(item => item.x > -item.width);
            
            if (gameOver || isRestarting) return;

            const minMountainSpawnDistance = canvas.width;
            const mountainSpawnChance = 0.005;

            let canSpawnMountain = sceneryArray.length === 0 || sceneryArray[sceneryArray.length - 1].x < canvas.width - minMountainSpawnDistance;
            if (canSpawnMountain && Math.random() < mountainSpawnChance) {
                sceneryArray.push(new Mountain());
            }
        }

        function handleObstacles(deltaTime) {
            obstaclesArray.forEach(obstacle => obstacle.update(deltaTime));

            if (gameOver || isRestarting) return;
            
            const minSpawnDistance = canvas.width / 1.2;
            const spawnChance = 0.015;

            let canSpawn = (obstaclesArray.length === 0 && gameFrame > 100) || (obstaclesArray.length > 0 && obstaclesArray[obstaclesArray.length - 1].x < canvas.width - minSpawnDistance);

            if (canSpawn && Math.random() < spawnChance) {
                // Determine current score milestone for bonus spawning
                let currentMilestoneKey = '0';
                if (score < 3000) currentMilestoneKey = '3000';
                else if (score < 6000) currentMilestoneKey = '6000';
                else if (score < 9000) currentMilestoneKey = '9000';
                else if (score < 12000) currentMilestoneKey = '12000';
                else if (score < 15000) currentMilestoneKey = '15000';
                else if (score < 19000) currentMilestoneKey = '19000';
                else if (score < 21000) currentMilestoneKey = '21000';
                
                let bonusSpawned = false;

                // Try to spawn TeleportGold
                if (bonusLimits.teleportGold[currentMilestoneKey] && bonusSpawns.teleportGold[currentMilestoneKey] < bonusLimits.teleportGold[currentMilestoneKey] && Math.random() < 0.15) {
                    obstaclesArray.push(new TeleportGold());
                    bonusSpawns.teleportGold[currentMilestoneKey]++;
                    bonusSpawned = true;
                } 
                // If not, try to spawn BonusPoints
                else if (bonusLimits.bonusPoints[currentMilestoneKey] && bonusSpawns.bonusPoints[currentMilestoneKey] < bonusLimits.bonusPoints[currentMilestoneKey] && Math.random() < 0.25) {
                    obstaclesArray.push(new BonusPoints());
                    bonusSpawns.bonusPoints[currentMilestoneKey]++;
                    bonusSpawned = true;
                }

                // If no bonus was spawned, spawn a regular obstacle
                if (!bonusSpawned) {
                    const obstacleType = Math.random();
                    if (obstacleType < 0.4) {
                        obstaclesArray.push(new Shuriken());
                    } else if (Math.random() < 0.5) {
                        obstaclesArray.push(new Lantern());
                    } else {
                        obstaclesArray.push(new Rock());
                    }
                }
            }
        }

        function addScore(points, color = {r:0, g:100, b:0}) {
            const oldScore = score;
            score += points;
            
            // Check if score crossed a 1000-point milestone
            if (Math.floor(score / 1000) > Math.floor(oldScore / 1000)) {
                sounds.kabuki.play();
            }
            
            // Check for 3000-point speed reset milestone
            if (score >= scoreMilestone * 3000) {
                resetGameForNextLevel();
                return true; // Signal that a reset happened
            }

            floatingScores.push(new FloatingScore(points, player.x + player.width / 2, player.y, color));
            return false; // No reset
        }

        function checkCollisionsAndScore() {
            if (gameOver) return;
            const playerHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
            const px = player.x + playerHitbox.offsetX;
            const py = player.y + playerHitbox.offsetY;
            const pw = playerHitbox.width;
            const ph = playerHitbox.height;

            for (let i = obstaclesArray.length - 1; i >= 0; i--) {
                const obstacle = obstaclesArray[i];
                const ox = obstacle.x + obstacle.hitbox.offsetX;
                const oy = obstacle.y + obstacle.hitbox.offsetY;
                const ow = obstacle.hitbox.width;
                const oh = obstacle.hitbox.height;

                if (px < ox + ow && px + pw > ox && py < oy + oh && py + ph > oy) {
                    if (obstacle instanceof TeleportGold) {
                        teleportCharges++;
                        sounds.secret.currentTime = 0;
                        sounds.secret.play();
                        obstaclesArray.splice(i, 1);
                    } else if (obstacle instanceof BonusPoints) {
                        const points = Math.floor(Math.random() * 151) + 150;
                        const didReset = addScore(points, {r: 0, g: 100, b: 255});
                        sounds.eat.currentTime = 0;
                        sounds.eat.play();
                        obstaclesArray.splice(i, 1);
                        if (didReset) return;
                    } else if (teleportCharges > 0) {
                        teleportCharges--;
                        player.isTeleporting = true;
                        sounds.teleport.currentTime = 0;
                        sounds.teleport.play();
                        effectsArray.push(new TeleportEffect(player.x, player.y, player.isJumping));
                        obstaclesArray.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.state = 'fall';
                        player.frame = 0;
                        sounds.end.play();
                        sounds.fail.play();
                        sounds.track.pause();
                        sounds.track.currentTime = 0;
                        obstaclesArray.splice(i, 1);
                        setTimeout(() => { canRestart = true; }, 2000);
                    }
                }

                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    obstacle.passed = true;
                    if (!(obstacle instanceof TeleportGold) && !(obstacle instanceof BonusPoints)) {
                        sounds.woosh.currentTime = 0;
                        sounds.woosh.play();
                        const points = 100; // All regular obstacles are 100 points
                        const didReset = addScore(points);
                        if (didReset) return;
                    }
                }
            }
        }

        function resetGameForNextLevel() {
            gameSpeed = 300;
            obstaclesArray = [];
            floatingScores = [];
            sounds.bell.play();
            scoreMilestone++;

            if (scoreMilestone === 2) { // Just passed 3000
                inversionTarget = 1;
            } else if (scoreMilestone === 3) { // Just passed 6000
                inversionTarget = 0;
            } else if (scoreMilestone === 4) { // Just passed 9000
                inversionTarget = 1;
            } else if (scoreMilestone === 5) { // Just passed 12000
                inversionTarget = 0;
            } else if (scoreMilestone === 6) { // Just passed 15000
                inversionTarget = 1;
            } else if (scoreMilestone === 7) { // Just passed 18000
                inversionTarget = 0;
            } else if (scoreMilestone === 8) { // Just passed 21000
                gameWon = true;
                sounds.track.pause();
                setTimeout(() => { canRestart = true; }, 2000);
            }

            if (!player.isJumping) {
                player.state = 'run';
                player.frame = 0;
            }
        }

        // --- Game Logic ---
        function update(deltaTime) {
            if (!gameStarted) return;
            
            if (isRestarting) {
                restartFadeAmount += 2 * fadeDirection * deltaTime;
                if (restartFadeAmount >= 1 && fadeDirection === 1) {
                    fadeDirection = -1;
                    // Full game reset
                    gameOver = false;
                    gameWon = false;
                    gameSpeed = 300;
                    score = 0;
                    gameFrame = 0;
                    obstaclesArray = [];
                    sceneryArray = [];
                    effectsArray = [];
                    floatingScores = [];
                    scoreMilestone = 1;
                    teleportCharges = 0;
                    inversionAmount = 0;
                    inversionTarget = 0;
                    bonusSpawns = {
                        teleportGold: { '3000': 0, '9000': 0, '15000': 0 },
                        bonusPoints: { '3000': 0, '6000': 0, '9000': 0, '12000': 0, '15000': 0, '19000': 0, '21000': 0 }
                    };
                    player.y = PLAYER_GROUND_LEVEL;
                    player.state = 'run';
                    player.frame = 0;
                    effectsArray.push(new RunCloud());
                    sounds.track.currentTime = 0;
                    sounds.track.play();
                }
                if (restartFadeAmount <= 0 && fadeDirection === -1) {
                    isRestarting = false;
                    fadeDirection = 1;
                }
                return; // Skip the rest of the update during transition
            }

            if (gameOver || gameWon) {
                if (gameSpeed > 0) gameSpeed -= 300 * deltaTime;
                else gameSpeed = 0;
                effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.startFading() });
            } else {
                gameSpeed += speedIncreaseRate * 60 * deltaTime;
            }

            // Smoothly update inversion amount
            const transitionSpeed = 1 / 4; // 4 seconds transition
            if (inversionAmount < inversionTarget) {
                inversionAmount = Math.min(inversionTarget, inversionAmount + transitionSpeed * deltaTime);
            } else if (inversionAmount > inversionTarget) {
                inversionAmount = Math.max(inversionTarget, inversionAmount - transitionSpeed * deltaTime);
            }

            groundX -= gameSpeed * deltaTime;
            bg1X -= gameSpeed * 0.1 * deltaTime;
            bg2X -= gameSpeed * 0.03 * deltaTime;
            grassX -= gameSpeed * GRASS_SPEED_MODIFIER * deltaTime;

            const bg1_scaledWidth = images.background1 ? images.background1.width * BG1_SCALE : 0;
            const bg2_scaledWidth = images.background2 ? images.background2.width * BG2_SCALE : 0;
            const grass_scaledWidth = images.grass ? images.grass.width * GRASS_SCALE : 0;

            if (groundX <= -images.ground.width) groundX = 0;
            if (bg1_scaledWidth > 0 && bg1X <= -bg1_scaledWidth) bg1X = 0;
            if (bg2_scaledWidth > 0 && bg2X <= -bg2_scaledWidth) bg2X = 0;
            if (grass_scaledWidth > 0 && grassX <= -grass_scaledWidth) grassX = 0;

            if (player.isJumping) {
                player.velocityY += GRAVITY * deltaTime;
                player.y += player.velocityY * deltaTime;
            }

            if (player.y > PLAYER_GROUND_LEVEL) {
                player.y = PLAYER_GROUND_LEVEL;
                if(player.isJumping) {
                    effectsArray.forEach(effect => { if(effect instanceof RunCloud) effect.activate() });
                }
                player.isJumping = false;
                player.velocityY = 0;
                if (!player.isCrouching && !gameOver) {
                    player.state = 'run';
                }
            }

            player.frameTimer += deltaTime;
            const stateData = animationStates[player.state];
            let dynamicFrameDuration = stateData.frameDuration;
            if (player.state === 'run' || player.state === 'crouch') {
                dynamicFrameDuration = Math.max(0.02, stateData.frameDuration - (gameSpeed / 10000));
            }
            if (player.frameTimer >= dynamicFrameDuration) {
                if (player.state === 'fall' || player.state === 'jump') {
                    if (player.frame < stateData.frames - 1) {
                        player.frame++;
                    }
                } else {
                    player.frame = (player.frame + 1) % stateData.frames;
                }
                player.frameTimer = 0;
            }

            effectsArray.forEach(effect => effect.update(deltaTime));
            effectsArray = effectsArray.filter(effect => !effect.markedForDeletion);
        }

        // --- Drawing Logic ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Inverted Pass ---
            ctx.save();
            ctx.filter = `invert(${inversionAmount * 100}%)`;
            
            // Draw a background rectangle that will be affected by the filter
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Backgrounds (from back to front)
            if (images.background2 && images.background2.complete && images.background2.naturalWidth > 0) {
                const scaledWidth = images.background2.width * BG2_SCALE;
                const scaledHeight = (images.background2.naturalHeight / images.background2.naturalWidth) * scaledWidth;
                ctx.drawImage(images.background2, bg2X, BG2_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.background2, bg2X + scaledWidth, BG2_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.background2, bg2X + scaledWidth * 2, BG2_Y_POS, scaledWidth, scaledHeight);
            }
            
            sceneryArray.forEach(item => item.draw());

            if (images.background1 && images.background1.complete && images.background1.naturalWidth > 0) {
                const scaledWidth = images.background1.width * BG1_SCALE;
                const scaledHeight = (images.background1.naturalHeight / images.background1.naturalWidth) * scaledWidth;
                ctx.drawImage(images.background1, bg1X, BG1_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.background1, bg1X + scaledWidth, BG1_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.background1, bg1X + scaledWidth * 2, BG1_Y_POS, scaledWidth, scaledHeight);
            }
            
            if (images.ground.complete && images.ground.naturalWidth > 0) {
                const groundY = canvas.height - GROUND_HEIGHT_PHYSICS + VISUAL_GROUND_Y_OFFSET;
                ctx.drawImage(images.ground, groundX, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                ctx.drawImage(images.ground, groundX + images.ground.width, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
                ctx.drawImage(images.ground, groundX + images.ground.width * 2, groundY, images.ground.width, VISUAL_GROUND_HEIGHT);
            }
            
            obstaclesArray.forEach(obstacle => obstacle.draw());
            
            effectsArray.forEach(effect => effect.draw());

            if (!player.isTeleporting) { // Only draw player if not teleporting
                const playerStateData = animationStates[player.state];
                if (images[player.state] && images[player.state].complete) {
                    const columns = playerStateData.columns;
                    const frameX = player.frame % columns;
                    const frameY = Math.floor(player.frame / columns);
                    const sourceX = frameX * PLAYER_SPRITE_WIDTH;
                    const sourceY = frameY * PLAYER_SPRITE_HEIGHT;
                    ctx.drawImage(images[player.state], sourceX, sourceY, PLAYER_SPRITE_WIDTH, PLAYER_SPRITE_HEIGHT, player.x, player.y, player.width, player.height);
                
                    if (DEBUG_MODE) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        let currentHitbox = player.isCrouching ? player.crouchHitbox : player.hitbox;
                        ctx.strokeRect(player.x + currentHitbox.offsetX, player.y + currentHitbox.offsetY, currentHitbox.width, currentHitbox.height);
                    }
                }
            }

            // Draw foreground grass
            if (images.grass && images.grass.complete && images.grass.naturalWidth > 0) {
                const scaledWidth = images.grass.width * GRASS_SCALE;
                const scaledHeight = images.grass.height * GRASS_SCALE;
                ctx.drawImage(images.grass, grassX, GRASS_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.grass, grassX + scaledWidth, GRASS_Y_POS, scaledWidth, scaledHeight);
                ctx.drawImage(images.grass, grassX + scaledWidth * 2, GRASS_Y_POS, scaledWidth, scaledHeight);
            }

            // Draw floating scores
            for (let i = floatingScores.length - 1; i >= 0; i--) {
                floatingScores[i].update(1/60); // Assuming 60fps for floating score update
                floatingScores[i].draw();
                if (floatingScores[i].opacity <= 0) {
                    floatingScores.splice(i, 1);
                }
            }

            // Draw score and teleport charges
            ctx.fillStyle = 'black';
            ctx.font = '30px "Segoe UI"';
            ctx.textAlign = 'right';
            ctx.fillText(`Score: ${score}`, canvas.width - 20, 40);
            ctx.textAlign = 'left';
            if (teleportCharges > 0 && images.teleportLogo.complete) {
                ctx.drawImage(images.teleportLogo, 20, 15, 40, 40);
                ctx.fillText(`x${teleportCharges}`, 65, 45);
            }
            ctx.textAlign = 'center'; // Reset for other text

            if (!gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = '30px "Segoe UI"';
                ctx.fillText('Press SPACE to Start', canvas.width / 2, canvas.height / 2);
            }

            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.font = '40px "Segoe UI"';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                if (canRestart) {
                    ctx.font = '20px "Segoe UI"';
                    ctx.fillText('press space to restart', canvas.width / 2, canvas.height / 2 + 20);
                }
            }

            if (gameWon) {
                ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '40px "Segoe UI"';
                ctx.fillText('YOU WIN', canvas.width / 2, canvas.height / 2 - 20);
                if (canRestart) {
                    ctx.font = '20px "Segoe UI"';
                    ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 20);
                }
            }
            
            ctx.restore(); // End of inverted pass

            // Draw restart fade overlay
            if (isRestarting) {
                ctx.fillStyle = `rgba(255, 255, 255, ${restartFadeAmount})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // --- Main Game Loop ---
        function gameLoop(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            update(deltaTime);
            handleScenery(deltaTime);
            handleObstacles(deltaTime);
            checkCollisionsAndScore();
            draw();
            
            gameFrame++;
            if (gameStarted) requestAnimationFrame(gameLoop);
        }

        function initialDraw() {
            if (assetsLoaded < totalAssets) {
                setTimeout(initialDraw, 50);
                return;
            }
            draw();
        }

        preloadAssets();
        initialDraw();

    </script>
</body>
</html>
